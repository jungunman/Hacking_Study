# 함수 리버싱
입력 값과 관련해 정확히 1개의 리턴값을 돌려주는 약속.<br>
함수 호출 시 입력값 전달 방법과 리턴값을 받는 방법에 대해 알아보는 마크업 파일이다.<br>
함수 프롤로그와 에필로그의 특징을 살펴볼 수 있다.<br>


## 콜링 컨벤션(Calling Convention)
함수 호출 시 인자를 전달받고 자신을 호출한 함수에게 리턴값을 돌려주는지에 대해 약속된 함수 호출 규약.<br><br>
__C언어에서 사용되는 대표적인 3개의 호출 규약.__<br>
| 구분 | __codecl | __stdcall | __fastcall |
|:---:|:---:|:---:|:---:|
| 인자 전달 방법 | 스택 | 스택 | 레지스터, 스택 |
| 스택 해제 방법 | 호출한 함수 | 호출된 함수 | 호출된 함수 |

### #__cdecl
Stack에 인자를 LIFO 형식으로 Push해서 인자를 전달하는 방법을 채택한다,<br>
함수 호출이 끝나면 그 이후 [ADD ESP,크기]만큼 스택을 해제하는 모습을 볼 수 있다.<br>
__cdecl 호출 규약은 호출한 함수에서 스택을 해제하기 때문에 호출된 함수에서는 스 택 해제에 대해 신경쓰지 않는다.<br>
스택 해제 방법에서 호출한 함수는 호출된 함수가 끝나고 호출한 함수로 돌아갔을 때 해제한다는 뜻이다.<br><br>

_FTZ 문제 풀 때, 함수에 인자를 전달하는 방식이 __cdecl 이었나보다._<br>


### #__stdcall
인자 전달 방법은 __cdecl과 같지만, 스택 해제 방법에서 차이가 보임.<br>
__cdecl에서 호출된 함수 내부에는 RETN의 명령어만 있고, 스택 해제하는 부분은 없었기에 호출한 함수 부분으로 돌아가기만하고,<br>
__stdcall 에서는 [RETN 0C]와 같이 호출한 함수로 돌아가면서 ESP를 0C만큼 더해주는 명령을 수행함.<br>
호출된 함수가 끝나고 다음 명령어를 수행할 때, 이미 인자 입력에 사용된 스택은 해제되었기에 스택을 효율적으로 사용할 수 있음.<br>

### #__fastcall
위 두 방법과 달리 인자 입력에 레지스터를 사용함.<br>
레지스터 사용에는 한계가 있기에 모든 인자를 레지스터로 입력하지 않고 스택(메모리)도 같이 사용함.<br>
스택 해제 방법은__stdcall과 같이 호출된 함수에서 해제하지만, 스택에 push된 크기만 해제할 뿐 레지스터에 저장된 값의 크기는 해제하지 않음.<br>
