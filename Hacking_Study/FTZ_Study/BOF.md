# Buffer OverFlow
- Stack OverFlow와 Heap OverFlow로 구분 지을 수 있으며, 주로 Stack OverFlow를 뜻한다.
- 버퍼에 데이터를 입력받을 때 흘러 넘치게 하여, 우리가 원하는 코드를 실행시킬 수 있게 만드는 버그.


## 알아두면 좋은 지식
1. 어셈블리어 기초
2. 레지스터에 대한 기초
3. 디스어셈블 툴
4. 스택 구조 및 방식
5. 리눅스 사용법
6. 검색

## 스택에 쌓이는 구조
Stack은 높은 주소에서 낮은 주소로 향한다. 높은 주소에서 원하는 공간만큼 빼며 공간을 확보하기 때문에, 나무가 위에서 아래로 자란다는 표현을 한다.<br><br>
BOF는 Buffer에 입력 받아야 할 값 이상을 입력해, 지정된 stack을 벗어나 윗 주소로 침범하게 만들고, EIP가 가르킬 RET의 공간에 우리가 심어둔 쉘 코드의 주소를 넣어두면 되는 것이다.<br>
함수(인자1,인자2,인자3)이 불러질 때 스택에 쌓이는 구조는 인자3,인자2,인자1 순으로 스택에 push하며 함수를 불러온다. 그리고 함수가 끝나면 사용한 stack의 공간을 다시 되돌리는 행위를 한다.<br>
이때 함수가 끝날 때, 함수를 Call했던 주소를 EIP가 가리키며 흐름이 끊이지 않도록 하는데, EIP가 가르킬 주소가 RET이라고 불리는 곳이다.<br>
정상적으로 EIP가 RET을 가리켰다면 Call다음의 명령줄로 이동할 것이나, 우리가 Buffer OverFlow를 일으킨다면, 우리가 원하는 주소로 이동하게 될 것이다.<br>
우리가 원하는 주소에 권한을 얻어오고, 쉘을 여는 쉘코드가 담겨있다면?<br>
치명적인 피해를 입을 수 있는 것이다.

## 환경변수를 이용한 BOF
우리가 쉘코드를 심을 stack의 공간이 부족하다던가, 우리가 원하는 주소를 알아내기 어렵다면 채택하는 방식이다.<br>
리눅스에서는 환경 변수를 설정할 수 있다. 환경 변수의 주소는 비교적 정확하게 알아낼 수 있기 때문에, 우리가 원하는 주소를 모른다면 사용할 수 있다.<br>
사용 방식은 환경 변수의 값을 쉘코드로 설정하고, 주소를 얻어내 EIP가 가리키는 곳에 환경 변수의 주소를 넣으면 된다.<br>
또, 쉘코드를 심을 Stack의 공간이 부족하는 경우는 char [10] buf 라는 코드가 있다고 가정했을 때, stack엔 dummy를 포함하여 대략 14byte를 할당할 것이다.<br>
쉘코드도 용량이 있기에 14btye 공간에 다 넣기 힘들 것이고, 그렇다면 우리는 쉘코드를 충분히 넣기 힘든 상황에 직면한다.<br>
그럴 때 역시 환경 변수를 이용하면 원하는 쉘코드를 모두 넣을 수 있다.<br>

