# Buffer OverFlow
- Stack OverFlow와 Heap OverFlow로 구분 지을 수 있으며, 주로 Stack OverFlow를 뜻한다.
- 버퍼에 데이터를 입력받을 때 흘러 넘치게 하여, 우리가 원하는 코드를 실행시킬 수 있게 만드는 버그.


## 알아두면 좋은 지식
1. 어셈블리어 기초
2. 레지스터에 대한 기초
3. 디스어셈블 툴
4. 스택 구조 및 방식
5. 리눅스 사용법
6. 검색

## 스택에 쌓이는 구조
Stack은 높은 주소에서 낮은 주소로 향한다. 높은 주소에서 원하는 공간만큼 빼며 공간을 확보하기 때문에, 나무가 위에서 아래로 자란다는 표현을 한다.
BOF는 Buffer에 입력 받아야 할 값 이상을 입력해, 지정된 stack을 벗어나 윗 주소로 침범하게 만들고, EIP가 가르킬 RET의 공간에 우리가 심어둔 쉘 코드의 주소를 넣어두면 되는 것이다.
함수(인자1,인자2,인자3)이 불러질 때 스택에 쌓이는 구조는 인자3,인자2,인자1 순으로 스택에 push하며 함수를 불러온다. 그리고 함수가 끝나면 사용한 stack의 공간을 다시 되돌리는 행위를 한다.
이때 함수가 끝날 때, 함수를 Call했던 주소를 EIP가 가리키며 흐름이 끊이지 않도록 하는데, EIP가 가르킬 주소가 RET이라고 불리는 곳이다.
정상적으로 EIP가 RET을 가리켰다면 Call다음의 명령줄로 이동할 것이나, 우리가 Buffer OverFlow를 일으킨다면, 우리가 원하는 주소로 이동하게 될 것이다.
우리가 원하는 주소에 권한을 얻어오고, 쉘을 여는 쉘코드가 담겨있다면?
치명적인 피해를 입을 수 있는 것이다.

## 환경변수를 이용한 BOF
우리가 쉘코드를 심을 stack의 공간이 부족하다던가, 우리가 원하는 주소를 알아내기 어렵다면 채택하는 방식이다.
리눅스에서는 환경 변수를 설정할 수 있다. 환경 변수의 주소는 비교적 정확하게 알아낼 수 있기 때문에, 우리가 원하는 주소를 모른다면 사용할 수 있다.
사용 방식은 환경 변수의 값을 쉘코드로 설정하고, 주소를 얻어내 EIP가 가리키는 곳에 환경 변수의 주소를 넣으면 된다.
또, 쉘코드를 심을 Stack의 공간이 부족하는 경우는 char [10] buf 라는 코드가 있다고 가정했을 때, stack엔 dummy를 포함하여 대략 14byte를 할당할 것이다.
쉘코드도 용량이 있기에 14btye 공간에 다 넣기 힘들 것이고, 그렇다면 우리는 쉘코드를 충분히 넣기 힘든 상황에 직면한다.
그럴 때 역시 환경 변수를 이용하면 원하는 쉘코드를 모두 넣을 수 있다.

